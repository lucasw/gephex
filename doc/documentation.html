<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>The GePhex Book</title><meta name="generator" content="DocBook XSL Stylesheets V1.64.1"><meta name="description" content="GePhex is an interactive effect system for video jockeys. The effects can be controlled with external devices like joysticks, web-cams, or midi-devices. New effects can be designed in a GUI (Graphical User Interface) by composing basic effects into more complex ones. This book gives new users an introduction to the GePhex system. The basic concept of effect-graphs is described. The reader learns how to use the system and the steps to create new effects. The last chapters hold information for developers."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="id2428568"></a>The GePhex Book</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Martin</span> <span class="surname">Bayer</span></h3><div class="affiliation"><div class="address"><p><tt class="email">&lt;<a href="mailto:bayer@fmi.uni-passau.de">bayer@fmi.uni-passau.de</a>&gt;</tt></p></div></div></div></div><div><div class="author"><h3 class="author"><span class="firstname">Georg</span> <span class="surname">Seidel</span></h3><div class="affiliation"><div class="address"><p><tt class="email">&lt;<a href="mailto:georg@gephex.org">georg@gephex.org</a>&gt;</tt></p></div></div></div></div><div><p class="copyright">Copyright © 2002, 2003 Martin Bayer, Georg Seidel</p></div><div><div class="legalnotice"><p>
    This document is free; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version. 
    </p><p>
    This document is distributed in the hope that it will be useful,
    but <span class="emphasis"><em>WITHOUT ANY WARRANTY</em></span>; without even the
    implied warranty of <span class="emphasis"><em>MERCHANTABILITY or FITNESS FOR A
    PARTICULAR PURPOSE</em></span>. See the GNU General Public License
    for more details.
    </p><p>
    You should have received a copy of the GNU General Public
    License along with this program; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
    MA 02111-1307 USA
    </p></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>GePhex is an interactive effect system for video jockeys. The effects can be controlled with external devices like joysticks, web-cams, or midi-devices. New effects can be designed in a GUI (Graphical User Interface) by composing basic effects into more complex ones.</p><p>This book gives new users an introduction to the GePhex system. The basic concept of effect-graphs is described. The reader learns how to use the system and the steps to create new effects. The last chapters hold information for developers.</p></div></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#id2430084">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2430089">What is GePhex</a></span></dt><dt><span class="sect1"><a href="#id2428624">GePhex's History</a></span></dt><dt><span class="sect1"><a href="#id2428664">Security Note</a></span></dt><dt><span class="sect1"><a href="#id2428678">GePhex's Components</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2428683">The Engine</a></span></dt><dt><span class="sect2"><a href="#id2477538">The GUI (graphical user interface)</a></span></dt><dt><span class="sect2"><a href="#id2429092">The GePhex Script</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#id2429141">2. Installation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2429159">Building from the Sources</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2429193"> Getting the latest Version from the Arch Archive </a></span></dt><dt><span class="sect2"><a href="#id2429268"> Getting a Distribution-Tarball </a></span></dt><dt><span class="sect2"><a href="#id2429313">Building on Unix Platforms</a></span></dt><dt><span class="sect2"><a href="#id2490207">Building on Windows</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2490805">Precompiled Versions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.apt">Using our APT Repository </a></span></dt><dt><span class="sect2"><a href="#id2490945">Windows binary Distribution</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#id2490963">3. Basic Concepts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2490968">The three States of Graphs in the Renderer</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id2491001">4. Guided Tour</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2491006"> Starting GePhex </a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2491012"> UN*X </a></span></dt><dt><span class="sect2"><a href="#id2491034"> Windows </a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2491047"> The GePhex Graphical User Interface </a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2491078"> Structure of the GUI </a></span></dt><dt><span class="sect2"><a href="#id2491128"> The First Graph </a></span></dt><dt><span class="sect2"><a href="#id2491252"> Adding Effects to the Graph </a></span></dt><dt><span class="sect2"><a href="#id2491351"> Configuring the Graph </a></span></dt><dt><span class="sect2"><a href="#id2491394"> Running and controlling the Graph </a></span></dt><dt><span class="sect2"><a href="#id2491452"> Saving the Graph </a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#id2491468">5. Example Graphs</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2491498">Example1: Tunnel-Vision</a></span></dt><dt><span class="sect1"><a href="#id2491513">Example2: Plasma</a></span></dt><dt><span class="sect1"><a href="#id2491523">Example3: A simple Feedback Loop</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id2491536">6. Module Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2491542">Generators</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2491547">ifsmodule</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2491586">Input Modules</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2491597">Video-playback (avifilemodule)</a></span></dt><dt><span class="sect2"><a href="#id2491701">Video for Linux (capturemodule)</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#id2491837">7. Type Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2491842">NumberType</a></span></dt><dt><span class="sect1"><a href="#id2491851">FrameBufferType</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id2491863">8. Developer Information</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2491888">Adding new data types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2491964">The c-API</a></span></dt><dt><span class="sect2"><a href="#id2492180">An example for a new data type</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2492400">Adding new effect modules</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2492432">The C-API</a></span></dt><dt><span class="sect2"><a href="#id2492581">Pluc the skeleton generator</a></span></dt><dt><span class="sect2"><a href="#id2493082">An example for a new module</a></span></dt></dl></dd></dl></dd></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>8.1. <a href="#id2492659">Most important pluc commands</a></dt><dt>8.2. <a href="#id2492722">Mandatory global settings</a></dt><dt>8.3. <a href="#id2492864">Mandatory input settings</a></dt><dt>8.4. <a href="#id2492964">Optional input settings</a></dt><dt>8.5. <a href="#id2493038">Mandatory output settings</a></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2430084"></a>Chapter 1. Introduction</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2430089">What is GePhex</a></span></dt><dt><span class="sect1"><a href="#id2428624">GePhex's History</a></span></dt><dt><span class="sect1"><a href="#id2428664">Security Note</a></span></dt><dt><span class="sect1"><a href="#id2428678">GePhex's Components</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2428683">The Engine</a></span></dt><dt><span class="sect2"><a href="#id2477538">The GUI (graphical user interface)</a></span></dt><dt><span class="sect2"><a href="#id2429092">The GePhex Script</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2430089"></a>What is GePhex</h2></div></div><div></div></div><p>GePhex is a software-based interactive video-effect system. Video jockeys can use this system to modify or recombine existing footage or create new video effects in an interactive process. External devices like joysticks, midi-keyboards, or web-cams can influence the real-time video generation.</p><p>

</p><div class="itemizedlist"><ul type="disc"><li><p>GePhex is Free Software.
You can use, distribute and modify GePhex under the terms of the GPL.
</p></li><li><p>GePhex is a multi platform project. Supported operating systems are Win32 and Linux. Ports to the BSD operating systems and Mac OSX are planned.</p></li></ul></div><p>
</p><p>

GePhex allows the construction and modification of video-effects on
different levels:

</p><div class="itemizedlist"><ul type="disc"><li><p>The users view of a video-effect is a data-flow graph with sources, modifiers and destinations. The data in these effect-graphs are typed. That means the inputs and outputs of the modules have types e.g. video, color or number. The user can create complex effects by connecting inputs and outputs of the same type.</p></li><li><p>Not all inputs must be connected. The user can set the values for unconnected inputs with the GUI. These values can be saved in so called snapshots.</p></li><li><p>The effects can be influenced by the environment in two ways. First, special source-modules inject data from hardware devices like midi-devices, web-cams, or joysticks. Second it is also possible to connect special GUI elements to the inputs of a module (think slide-bars, color choosers, file dialogs, ...).</p></li><li><p>Developers can extend the system with the plugin mechanism for modules and types.</p></li></ul></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2428624"></a>GePhex's History</h2></div></div><div></div></div><p>

</p><div class="itemizedlist"><ul type="disc"><li><p>The project started in the late summer 2001.</p></li><li><p>In autumn 2002 was the first public vjing session at the fmi party on the campus of the university of Passau, Germany.</p></li><li><p>In autumn 2003 there was a public session in Vienna and another session at the fmi party in Passau, Germany. </p></li><li><p>In December 2003 we released the first stable version (0.0.4).     </p></li><li><p>In June 2004 we released the second stable version (0.4). </p></li></ul></div><p>

</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2428664"></a>Security Note</h2></div></div><div></div></div><p>With the default configuration the GePhex engine listens at the TCP port 6666. The GUI connects to this port to control the engine. There is no authentication necessary to connect to the engine.
This could be a security hole if used in a hostile environment. Never start this software as root and don't use it in an network that is connected to the internet without protection (e.g. a firewall).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2428678"></a>GePhex's Components</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2428683"></a>The Engine</h3></div></div><div></div></div><p>The engine can be started from the console with the <tt class="filename">gephex-engine</tt> command.
The only environment variable that is used is DISPLAY for the output under X11.
All options are set in the configuration file <tt class="filename">~/.gephex/gephex.conf</tt>. If no file exists a default configuration file is created.</p><p>
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
common {
    media_path           = [/home/tmp/seidel/gphx/share/gephex]
}

engine {
    module_path          = [/home/tmp/seidel/gphx/lib/gephex/modules/]
    type_path            = [/home/tmp/seidel/gphx/lib/gephex/types/]
    graph_path           = [/home/cip/seidel/.gephex/graphs/]
    ipc_unix_node_prefix = [/tmp/gephex_socket_]
    ipc_type             = [inet]
    ipc_port             = [6666]
    renderer_interval    = [40]
    net_interval         = [40]
}
...
</pre></td></tr></table><p>
<tt class="varname">media_path</tt> is used for both engine and gui. It is a
semicolon separated list of directories, which contain media for GePhex
(i.e. images, videos, fonts, ...).
<tt class="varname">module_path</tt> is the absolute path to the directory with the effect plugins.
The shared libraries for the types are stored in the <tt class="varname">type_path</tt>.
The <tt class="varname">graph_path</tt> variable tells the engine the location of the user created graphs (semicolon separated list of directories).
The user interface must connect to the engine with a ipc mechanism <tt class="varname">ipc_type</tt>.
You can select between <tt class="literal">inet</tt> for a internet-protocol based communication, on Unix platforms <tt class="literal">unix</tt> for Unix domain sockets and <tt class="literal">namedpipe</tt> for named pipes on win32 systems.
If engine and GUI run on the same host the usage of non ip based communication is preferred because it has less overhead.

The parameters <tt class="literal">ipc_unix_node_prefix</tt> and <tt class="literal">ipc_port</tt> must equal to the ones for the gui.
</p><p>
All options that can be set in the config file can be overridden from the
command line. For example
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
  &gt; gephex-engine --ipc_port=1234
</pre></td></tr></table><p>
overrides the value of the option <tt class="varname">ipc_port</tt>.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2477538"></a>The GUI (graphical user interface)</h3></div></div><div></div></div><p>
The gui can be started on the console with the <tt class="filename">gephex-gui</tt> command.
At the moment there are no command-line options and environment variables that influence the behavior.
All options are set in the configuration file <tt class="filename">~/.gephex/gephex.conf</tt>. If no file exists a default configuration file is created.</p><p>
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
common {
    media_path           = [/home/tmp/seidel/gphx/share/gephex]
}

...

gui {
    ipc_type             = [inet]
    ipc_inet_hostname    = [localhost]
    ipc_port             = [6666]
    ipc_unix_node_prefix = [/tmp/gephex_socket_]
    engine_binary        = [/home/tmp/seidel/gphx/bin/gephex-engine]
}
</pre></td></tr></table><p>
<tt class="varname">media_path</tt> is used for both engine and gui. It is a
semicolon separated list of directories, which contain media for GePhex
(i.e. images, videos, fonts, ...).
The user interface must connect to the engine with a ipc mechanism <tt class="varname">ipc_type</tt>.
You can select between <tt class="literal">inet</tt> for a internet-protocol based communication, on Unix platforms <tt class="literal">unix</tt> for Unix domain sockets and <tt class="literal">namedpipe</tt> for named pipes on win32 systems.
If engine and GUI run on the same host the usage of non ip based communication is preferred because it has less overhead.
The parameters <tt class="literal">ipc_unix_node_prefix</tt>, <tt class="literal">ipc_namedpipe_servername</tt>, and <tt class="literal">ipc_port</tt> must equal to the ones in for the engine.
<tt class="varname">engine_binary</tt> is the full path of the engine executable. It is used to spawn a engine process if necessary.
</p><p>
All options that can be set in the config file can be overridden from the
command line. For example
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
  &gt; gephex-gui --media_path=/mnt/data/footage/
</pre></td></tr></table><p>
overrides the value of the option <tt class="varname">media_path</tt>.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2429092"></a>The GePhex Script</h3></div></div><div></div></div><p>
  On unix platforms, a script called gephex is installed.
  It takes care of starting the engine and the gui.
</p><p>
  The engine is started in an x-terminal-emulator, which defaults
  to x-terminal-emulator, and if that does not exists on your
  system xterm is used.
</p><p>
  To override this behavior, you can set the GEPHEX_XTERM
  environment variable. Make sure that your terminal emulator
  accepts the "-e" flag to execute a program.
  To add extra flags to your terminal emulator, use the
  GEPHEX_XTERM_FLAGS environment variable.
  Example:
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
   &gt; GEPHEX_XTERM=aterm GEPHEX_XTERM_FLAGS="-fg green -bg black" gephex
</pre></td></tr></table><p>
</p><p>
  If you need even more control, look at the file
  ~/.gephex/run_in_terminal.sh. If you want to restore the default for some
  reason, it's OK to simply delete it, gephex will copy the default file
  if it does not find it there.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p> The gui uses the same mechanism to start the engine, so
you can provide the GEPHEX_XTERM* variables for the gui, too. </p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2429141"></a>Chapter 2. Installation</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2429159">Building from the Sources</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2429193"> Getting the latest Version from the Arch Archive </a></span></dt><dt><span class="sect2"><a href="#id2429268"> Getting a Distribution-Tarball </a></span></dt><dt><span class="sect2"><a href="#id2429313">Building on Unix Platforms</a></span></dt><dt><span class="sect2"><a href="#id2490207">Building on Windows</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2490805">Precompiled Versions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.apt">Using our APT Repository </a></span></dt><dt><span class="sect2"><a href="#id2490945">Windows binary Distribution</a></span></dt></dl></dd></dl></div><p>Since GePhex is free software you can get the source code and compile it on you own.
Or if you have one of our core platforms you can download the precompiled binaries from our <a href="http://www.gephex.org" target="_top"><i class="citetitle">website</i></a>.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2429159"></a>Building from the Sources</h2></div></div><div></div></div><p>
    It is not very difficult to compile your own version of GePhex.
    Especially on Unix, if you already installed software with "configure" 
    and "make install" there should be no big surprises for you here.
    On windows, you need a copy of ms visual studio 6 and several libraries.
  </p><p>
    Before we can start we must get a version of the GePhex source code.
    There are official releases as tar balls on the 
    <a href="http://www.gephex.org/download.php" target="_top"><i class="citetitle">website</i></a> and the developer versions available via <a href="http://www.gnu.org/software/gnu-arch/" target="_top"><i class="citetitle">arch</i></a>.
  </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2429193"></a> Getting the latest Version from the Arch Archive </h3></div></div><div></div></div><p>
      I assume that you use the tla arch-client. 
      To get the latest version you need to register the gephex archive.
      The name of the archive is <tt class="filename">gephex@gephex.org--2004</tt>
      and the location is <tt class="filename">http://arch.gephex.org/gephex/2004</tt>.
      </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
bash@host:~$ tla register-archive http://arch.gephex.org/gephex/2004
Registering archive: gephex@gephex.org--2004
bash@host:~$ 
      </pre></td></tr></table><p>
    </p><p>
      The full name of the revision is <tt class="filename">gephex--main--0.4</tt>:
      </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
bash@host:~$ tla get -A gephex@gephex.org--2004 gephex--main--0.4 GePhex
* from archive cached: gephex@gephex.org--2004/gephex--main--0.4--patch-1727
* patching for revision: gephex@gephex.org--2004/gephex--main--0.4--patch-1728
* making pristine copy
* tree version set gephex@gephex.org--2004/gephex--main--0.4
bash@host:~$
      </pre></td></tr></table><p>
      This command will fetch the latest version of gephex into the directory
      <tt class="filename">./GePhex</tt>.
    </p><p>
    If you have questions regarding arch please have a look at the projects <a href="http://www.gnu.org/software/gnu-arch/" target="_top"><i class="citetitle">homepage</i></a>.
    </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2429268"></a> Getting a Distribution-Tarball </h3></div></div><div></div></div><p>
      Visit our
      <a href="http://gephex.org/download.php" target="_top">
        <i class="citetitle">download page</i>
      </a> and get a release.
       Let's assume the tar ball is called 
       <tt class="filename">gephex-0.4.tar.gz</tt>.
      Just unpack the file.
     </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
bash@host:~$ tar xvzf gephex-0.4.tar.gz
gephex-0.4/AUTHORS
gephex-0.4/BUGS
gephex-0.4/ChangeLog
gephex-0.4/INSTALL
...
     </pre></td></tr></table><p>
     On windows you can use, for example, 
     <a href="http://www.rarlab.com" target="_top"><i class="citetitle">WinRAR</i></a>
     to unpack the file.
   </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2429313"></a>Building on Unix Platforms</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2427885"></a> Bootstrapping </h4></div></div><div></div></div><p>
     This step is only necessary when you got the sources from the arch
     repository. The distributed tar balls are already "bootstrapped".
   </p><p>
      To do the bootstrapping, you need some additional software.
      This includes autoconf and automake and some additional packages
      to build the documentation etc.
      You should use rather new versions of automake and autoconf.
      For automake, 1.8 is known to work and 1.4 is known to *not*
      work with our build system. For autoconf, 2.59 is known to work.
   </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
       When installing from a tar ball, this software is *not* needed!
     </p></div><div class="itemizedlist"><ul type="disc"><li><p>
       <a href="http://www.gnu.org/software/autoconf/" target="_top">
         <i class="citetitle"> autoconf</i></a>
       <a href="http://www.gnu.org/software/automake/" target="_top">
         <i class="citetitle"> automake</i></a>
       <a href="http://www.gnu.org/software/libtool/" target="_top">
         <i class="citetitle"> libtool</i></a>
     </p></li><li><p>
       <a href="http://www.python.org/" target="_top">
         <i class="citetitle"> python</i></a>
     </p></li><li><p>
       <a href="http://docbook.sourceforge.net/projects/docbook/" target="_top">
         <i class="citetitle">  DocBook DTD</i></a>
       <a href="http://docbook.sourceforge.net/projects/xsl/" target="_top">
         <i class="citetitle">  DocBook XSL Stylesheets</i></a>
       <a href="http://xmlsoft.org/XSLT/" target="_top">
         <i class="citetitle"> xsltproc</i></a>
       <a href="http://docbook2x.sourceforge.net" target="_top">
         <i class="citetitle"> docbook2x</i></a>
     </p></li></ul></div><p>
  GePhex uses autoconf and automake for the configuration and generation of
  Makefiles.
  Use the script <tt class="filename">bootstrap.sh</tt> to create the
  build-system without further intervention.
  </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
bash@host:~$ cd GePhex
bash@host:~/GePhex$./bootstrap.sh
running aclocal ...
running libtoolize --force ...
running autoheader ...
running automake --add-missing --copy ...
running autoconf ...

./configure has been successfully built!
See './configure --help' for available options 
  </pre></td></tr></table><p>
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2428021"></a> Configure and Build </h4></div></div><div></div></div><p>
    This step configures the build system for your system.
    You need the following libraries to get all the features of GePhex:

    </p><div class="itemizedlist"><ul type="disc"><li><p>
        <a href="http://doc.trolltech.com/3.3/index.html" target="_top">
          <i class="citetitle"> libqt</i></a>
        <a href="http://www.xfree.org/" target="_top">
          <i class="citetitle"> xlib</i></a>
      </p></li><li><p>
        <a href="http://www.libsdl.org/index.php" target="_top">
          <i class="citetitle"> libsdl</i></a>
        <a href="http://www.libpng.org/pub/png/libpng.html" target="_top">
          <i class="citetitle"> libpng</i></a>
        <a href="http://www.mesa3d.org/" target="_top">
          <i class="citetitle"> mesa</i></a>
        <a href="http://avifile.sourceforge.net/" target="_top">
          <i class="citetitle"> avifile</i></a>
        <a href="http://alsa-project.org/" target="_top">
          <i class="citetitle"> alsa</i></a>
        <a href="http://aa-project.sourceforge.net/aalib/" target="_top">
          <i class="citetitle"> aalib</i></a>
      </p></li></ul></div><p>
  </p><p>
    At the very least you should have libqt and xlib installed.
    If not the GUI will not be built.
  </p><p>
    At this point you can choose the location where the software should be
    installed. Some special options to include/exclude features can
    also be activated here.
    E.g. if you have a recent x86 processor you could enable the faster MMX
    implementation for some modules.
  </p><p>
    To see the available options you can use the
    <tt class="filename"> configure </tt> script:
    </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
bash@host:~/GePhex$./configure --help
`configure' configures this package to adapt to many kinds of systems.
...
Installation directories:
  --prefix=PREFIX         install architecture-independent files in PREFIX
                          [/usr/local]
...
Optional Features:
...
  --enable-mmx            Turn on MMX support. Still runs on x86 that don't
                          have MMX!
  --enable-serialize-framebuffer
                          Serialize the framebuffer type (for previews in the
                          gui).

 Optional Packages:
...
    </pre></td></tr></table><p>
  </p><p>
    So let's do the actual configuration:
    </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
bash@host:~/GePhex$ ./configure --enable-mmx --with-v4l --prefix=/usr
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking for g++... g++
...
    </pre></td></tr></table><p>
  </p><p>
    Now we can start the build process.
    Depending on you system this could take a long time.
    </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
bash@host:~/GePhex$ make
make  all-recursive
make[1]: Entering directory `/home/martin/code/gephex/GePhex'
Making all in base
make[2]: Entering directory `/home/martin/code/gephex/GePhex/base'
Making all in src
make[3]: Entering directory `/home/martin/code/gephex/GePhex/base/src'
...
    </pre></td></tr></table><p>
  </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2428182"></a> Installation </h4></div></div><div></div></div><p>
    The following command installs the software on your system.
    The two binaries for the user interface <tt class="filename">gephex-gui</tt>
    and the rendering engine <tt class="filename">gephex-engine</tt> will be
    installed in the <tt class="filename">PREFIX/bin</tt> directory and the
    location of the plugins is in <tt class="filename">PREFIX/lib/gephex</tt>.
    </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
bash@host:~/GePhex# make install
    </pre></td></tr></table><p>
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
      You might need to be root to install (depending on the 
      installation prefix you chose).
    </p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2428234"></a>Create your own Debian Packages</h4></div></div><div></div></div><p>Users of the Debian GNU/Linux OS can create Debian binary packages from the source and install these as root with dpkg.</p><p>To build Debian packages you need these Debian packages installed:
</p><div class="itemizedlist"><ul type="disc"><li><p>debhelper</p></li><li><p>libqt3-mt-dev</p></li><li><p>libsdl1.2-dev</p></li><li><p>xlibmesa-dev</p></li><li><p>libpng12-dev</p></li><li><p>libavifile-0.7-dev</p></li><li><p>libsdl-ttf2.0-dev</p></li><li><p>libasound2-dev</p></li><li><p>libmpeg3-dev</p></li><li><p>libsdl-image1.2-dev</p></li><li><p>automake1.8</p></li><li><p>libtool</p></li><li><p>autoconf</p></li><li><p>python</p></li><li><p>docbook-xml</p></li><li><p>docbook-xsl</p></li><li><p>docbook2x</p></li><li><p>xsltproc</p></li></ul></div><p>
</p><p>Not all necessary files for building the Debian packages are included in the dist tar balls. You need to get a full copy of the gephex source tree from the arch repository. The necessary steps to do this are described above.</p><p>First bootstrap the clean source tree by calling the bootstrap.sh script in the root of the source tree. Then build the packages with the dpkg-buildpackage commando. After a successful build you can install the generated packages as superuser with dpkg.

</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
bash@host:~/GePhex$ ./bootstrap
bash@host:~/GePhex$ fakeroot dpkg-buildpackage
bash@host:~/GePhex$ sudo dpkg -i ../gephex_0.4-1_i386.deb
</pre></td></tr></table><p>

</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2490207"></a>Building on Windows</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2490212"></a>What you need</h4></div></div><div></div></div><p>
The following programs and libraries are needed
to compile gephex on win32:

</p><div class="itemizedlist"><ul type="disc"><li><p> ms visual studio 6 (at least the command line interpreter)
  </p></li><li><p> <a href="http://www.python.org/download/" target="_top"> <i class="citetitle">python</i> </a> </p></li><li><p> <a href="http://nasm.sourceforge.net/" target="_top"><i class="citetitle">nasm</i></a> </p></li><li><p><a href="http://www.trolltech.com/download/qt/download_noncomm.html" target="_top"><i class="citetitle"> libqt (2.3nc)</i></a> </p></li><li><p><a href="http://libsdl.org" target="_top"><i class="citetitle">sdl</i></a></p></li><li><p><a href="http://www.libsdl.org/projects/SDL_image" target="_top"><i class="citetitle">sdl-image</i></a></p></li><li><p><a href="http://www.libsdl.org/projects/SDL_ttf" target="_top"><i class="citetitle">sdl-ttf (choose the devel zip file for visual studio 6)</i></a></p></li><li><p><a href="http://www.microsoft.com/windows/directx/default.aspx" target="_top"><i class="citetitle">directx sdk</i></a></p></li><li><p><a href="http://ffmpeg.sourceforge.net" target="_top"><i class="citetitle">ffmpeg (distributed with GePhex in source form)</i></a></p></li><li><p><a href="http://www.mingw.org" target="_top"><i class="citetitle">MinGW/MSYS (needed to compile ffmpeg)</i></a></p></li></ul></div><p>
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2490326"></a>Environment and Path</h4></div></div><div></div></div><p>
The python, nasm and qt (uic, moc) binaries must be in the PATH.
You need to set up the following environment variables:

</p><div class="variablelist"><dl><dt><span class="term">SDL_DIR</span></dt><dd><p>base dir of SDL</p></dd><dt><span class="term">SDL_DIR</span></dt><dd><p>base dir of sdl</p></dd><dt><span class="term">SDL_IMAGE_DIR</span></dt><dd><p>base dir of sdl-image</p></dd><dt><span class="term">SDL_TTF_DIR</span></dt><dd><p>base dir of sdl-ttf</p></dd><dt><span class="term">QTDIR</span></dt><dd><p>base dir of qt</p></dd><dt><span class="term">DXSDK_DIR</span></dt><dd><p>base dir of directx sdk</p></dd></dl></div><p>
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2490392"></a>Building ffmpeg</h4></div></div><div></div></div><p>
Before building GePhex, ffmpeg must be built.
Fire up MSYS and chdir into &#8220;<span class="quote">${gephex-dist}/contrib/ffmpeg</span>&#8221;.
Then execute
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
 &gt; ./configure --enable-shared
 &gt; make
</pre></td></tr></table><p>
If everything works out, the necessary dlls are now in
&#8220;<span class="quote">${gephex-dist}/contrib/ffmpeg/libavformat</span>&#8221; and
&#8220;<span class="quote">${gephex-dist}/contrib/ffmpeg/libavcodec</span>&#8221;.

There are two ways to build GePhex (all paths are relative to your gephex dir):
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2490424"></a>Building with the Visual Studio IDE</h4></div></div><div></div></div><p>

 Create the following empty folders in your gephex dir:

</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="filename">$gephex-dir/dlls</tt></p></li><li><p><tt class="filename">$gephex-dir/dlls/modules</tt></p></li><li><p><tt class="filename">$gephex-dir/dlls/types</tt></p></li><li><p><tt class="filename">$gephex-dir/graphs</tt></p></li></ul></div><p>

 Copy 

 </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="filename">$gephex-dir/data/gephexw.conf.default</tt> to <tt class="filename">$gephex-dir/gephex.conf</tt>,</p></li><li><p><tt class="filename">$gephex-dir/config_h.win32</tt> to <tt class="filename">$gephex-dir/config.h</tt>, and</p></li><li><p>the graphs in <tt class="filename">$gephex-dir/examples/graphs</tt> to <tt class="filename">$gephex-dir/graphs</tt>.</p></li></ul></div><p>

 Fire up vs6 and open <tt class="filename">$gephex-dir/build/gephex.dsw</tt>.

 Choose your configuration (Release/Debug).

 You have to build three projects:
</p><div class="itemizedlist"><ul type="disc"><li><p>engine</p></li><li><p>gui</p></li><li><p>dummy (builds all modules and types)</p></li></ul></div><p>

</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2490547"></a>Building via the Command Line</h4></div></div><div></div></div><p>

</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
 Unfortunately, vs6 puts hard paths into .mak files and .dep files.
 Although the dsp files are controlled by the above environment variables,
 the console build will probably only work if you have installed
 the gephex source and your libraries into the following directories:

 </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="filename">GEPHEX_DIR</tt> = <tt class="filename">c:/code/gephex-0.4</tt> (and _not_ <tt class="filename">c:/code/gephex-0.4.x</tt>!) </p></li><li><p><tt class="filename">SDL_DIR</tt> = <tt class="filename">c:/code/sdl</tt> </p></li><li><p><tt class="filename">SDL_IMAGE_DIR</tt> = <tt class="filename">c:/code/sdl_image</tt> </p></li><li><p><tt class="filename">SDL_TTF_DIR</tt> = <tt class="filename">c:/code/sdl_ttf</tt> </p></li><li><p><tt class="filename">QTDIR</tt> = <tt class="filename">c:/code/qt</tt> </p></li><li><p><tt class="filename">DXSDK_DIR</tt> = <tt class="filename">c:/dxsdk</tt> </p></li></ul></div><p>

 Additionally, you have to rename your gephex dir to <tt class="filename">C:\code\gephex-0.4</tt>.

 (If anybody knows a better way to create the .mak and .dep files, please
  tell us!)
</p></div><p>


 The batch file <tt class="filename">$gephex-dir/build/make_all.bat</tt> should build everything.
 </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
   &gt; cd build
   &gt; make_all Release
 </pre></td></tr></table><p>

 </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
 <tt class="filename">nmake</tt> seems to crash when called from inside cygwin.
 Use the windows command line instead.
 </p></div><p>

</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2490697"></a>Making it work</h4></div></div><div></div></div><p>

Wether you built GePhex with the IDE or with the CLI, you need to make sure
that the dlls of the libraries are found when gephex is started.
The easiest thing is to put them into <tt class="filename">$gephex-dir/bin</tt>.
Alternatively, you could put the dlls into a system path, like
<tt class="filename">c:\windows</tt>.
The following dlls are needed:

</p><div class="itemizedlist"><ul type="disc"><li><p>sdl.dll</p></li><li><p>sdl_ttf.dll</p></li><li><p>sdl_image.dll</p></li><li><p>jpeg.dll</p></li><li><p>libpng1.dll</p></li><li><p>zlib.dll</p></li><li><p>qt-mt230nc.dll</p></li><li><p>avcodec.dll</p></li><li><p>avformat.dll</p></li></ul></div><p>

Instead of copying these files manually, you can put them into
<tt class="filename">C:\gphx_dist_data\extra_dlls</tt>.
Then, you can use the script
<tt class="filename">$gephex-dir/build/make_binary_dist.bat</tt> to create
a working binary distribution.
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
  &gt; cd build
  &gt; make_binary_dist C:\my_gephex_0.4_dist
</pre></td></tr></table><p>

</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
You need the recode utility, available with the 
<a href="http://unxutils.sourceforge.net/" target="_top">
<i class="citetitle">UnxUtils</i></a> for this batch file.
</p></div><p>

</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2490805"></a>Precompiled Versions</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sec.apt"></a>Using our APT Repository </h3></div></div><div></div></div><p>The Debian binary package format is the common way to install software on a Debian GNU/Linux system. Using the dpkg, a medium-level tool to install, build, remove and manage Debian GNU/Linux packages, the system stays in a consistent state after changes to the software installation or configuration. The proper deinstallation and upgrade to a other version of the application package is guaranteed.</p><p>Add the GePhex apt repository lines to your /etc/apt/sources.list and install GePhex with apt-get:
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
bash@host:~$ sudo cat &gt;&gt; /etc/apt/sources.list
deb http://www.gephex.org/debian/ unstable main 
bash@host:~$ sudo apt-get install gephex
</pre></td></tr></table><p>
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2490945"></a>Windows binary Distribution</h3></div></div><div></div></div><p>
  Just get the windows binary .rar or .zip file and unpack it.
  GePhex can be started from the <tt class="filename">bin</tt> directory.
</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2490963"></a>Chapter 3. Basic Concepts</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2490968">The three States of Graphs in the Renderer</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2490968"></a>The three States of Graphs in the Renderer</h2></div></div><div></div></div><p>
The Renderer knows three states for a graph:
</p><div class="itemizedlist"><ul type="disc"><li><p>The graph is not loaded. No internal state of the modules is stored and obvious no calculation is done in this state.</p></li><li><p>The graph is loaded in the renderer. The modules remember their internal states e.g. the framebuffer of an xfader with loopback. But no calculation is allowed in this state.</p></li><li><p>Only in the state active are any calculations done.</p></li></ul></div><p>
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2491001"></a>Chapter 4. Guided Tour</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2491006"> Starting GePhex </a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2491012"> UN*X </a></span></dt><dt><span class="sect2"><a href="#id2491034"> Windows </a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2491047"> The GePhex Graphical User Interface </a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2491078"> Structure of the GUI </a></span></dt><dt><span class="sect2"><a href="#id2491128"> The First Graph </a></span></dt><dt><span class="sect2"><a href="#id2491252"> Adding Effects to the Graph </a></span></dt><dt><span class="sect2"><a href="#id2491351"> Configuring the Graph </a></span></dt><dt><span class="sect2"><a href="#id2491394"> Running and controlling the Graph </a></span></dt><dt><span class="sect2"><a href="#id2491452"> Saving the Graph </a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2491006"></a> Starting GePhex </h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2491012"></a> UN*X </h3></div></div><div></div></div><p>
          You can start GePhex by executing 
          <tt class="filename">gephex</tt>.
       </p><p>
          If you chose your own prefix for the install, make sure the 
          gephex binary is in the path.
       </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2491034"></a> Windows </h3></div></div><div></div></div><p>
          Just go into the bin directory of your GePhex directory and
          execute the gephex-engine and gephex-gui (in that order).
       </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2491047"></a> The GePhex Graphical User Interface </h2></div></div><div></div></div><div class="mediaobject"><img src="images/gui_1.png" alt="The GUI (just started)."><div class="caption"><p> The GUI (just started). </p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2491078"></a> Structure of the GUI </h3></div></div><div></div></div><p>
        As you can see in the image, the GUI (Graphical User Interface)
        is divided into four major areas.
        The areas are marked with a red pen.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              1: Info-window. Used for properties of effects and
              for loading and saving effect-graphs,
            </p></li><li><p>
              2: Graph-window. Used to edit effect-graphs.
            </p></li><li><p>
              3: Control-window. Used to control running effect-graphs.
            </p></li><li><p>
              4: Message-window. Used to display error
              and warning messages.
            </p></li></ul></div><p>
     </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2491128"></a> The First Graph </h3></div></div><div></div></div><p>
        The most important concept for using GePhex is that of an effect-graph.
        An effect-graph is a number of simple basic effects, combined to
        perform a more complex effect.
     </p><p>
        Since GePhex works with graphs, we have to tell it which graph
        we want to edit.
        Do this by clicking on the "Graphs" tab in the info-window.
        To create a new graph, right-click on the "Graphs" item inside the
        tab (see next image).
     </p><div class="mediaobject"><img src="images/gui_2.png" alt="Creating a graph."><div class="caption"><p> Creating a graph </p></div></div><p>
        When the context-menu opens up, just select "New Graph".
        Enter "first" in the dialog.
     </p><div class="mediaobject"><img src="images/gui_3.png" alt=" Choosing the name of the graph."><div class="caption"><p> Choosing the name of the graph </p></div></div><p>
       Now you see another item called "first" in the tree-view below
       "default". This is our new graph.
       To activate it, click on the arrow (or plus symbol) left to "first".
       Click on the appearing child item "default".
     </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
         This child item is a "snapshot" of the graph. For now you just
         need to know, that you need one active graph with one active snapshot
         in order to create an effect.
       </p></div><p>
       The letters "r" and "e"
       tell you that graph "first" is active (with current snapshot "default").
     </p><div class="mediaobject"><img src="images/gui_4.png" alt="Activating the graph."><div class="caption"><p> Activating the graph </p></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2491252"></a> Adding Effects to the Graph </h3></div></div><div></div></div><p>
       Now we have created a new graph. But it is not very useful yet, because
       it is empty. So let's create some effects.
     </p><p>
       To do so, open the "Effects" menu in the top-level menu-bar.
       Choose "Sources"-&gt;"Image Source".
       Then click into the graph window as shown in the next image.
     </p><div class="mediaobject"><img src="images/gui_5.png" alt="Adding an basic effect."><div class="caption"><p> Adding an basic effect </p></div></div><p>
       Do the same for "Effects"-&gt;"Outputs"-&gt;"Image Output" 
       and "Effects"-&gt;"Filter"-&gt;"FlashFader".
       Arrange them as in the next image (You can simply move them around with
       the mouse).
     </p><p>
       The red boxes on the left side of the basic effects are
       inputs, the blue buttons on the right are outputs.
     </p><p>
       Connect the effects as shown in the next picture:
     </p><div class="mediaobject"><img src="images/gui_6.png" alt="Connecting effects."><div class="caption"><p> Connecting effects </p></div></div><p>
       The graph we have created so far is still very simple. In fact,
       you would not call such a graph an effect at all.
       What it does is simply loading a bitmap, eventually flashing it and
       displaying it to the screen.
     </p><p>
       You can think of this graph in terms of data flow:
       data comes from a source (the image source), flows through the
       flash-fader filter and is displayed in the sink (the image output).
     </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2491351"></a> Configuring the Graph </h3></div></div><div></div></div><p>
        This is simple. We just choose a bitmap.
        Right-click on the "Image Source"-effect and choose "Properties"
        in the context menu. Now the info-window displays the properties
        of the image source:
     </p><div class="mediaobject"><img src="images/gui_7.png" alt="Properties"><div class="caption"><p> Properties </p></div></div><p>
       Click on the button next to "Filename" and choose a nice image file.
     </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2491394"></a> Running and controlling the Graph </h3></div></div><div></div></div><p>
        Simple again. Just click on the little red fellow on the bottom right.
        You should see the output window opening and displaying the bmp file
        you chose.
        To inform you that it is running, GePhex turns the red fellow to a
        green fellow.
     </p><p>
        To control the flash-fader effect we must add a control at the upper
        input of the flash-fader.
        The following picture explains how you can add a control to an input: 
     </p><div class="mediaobject"><img src="images/gui_8.png" alt="Creating a control."><div class="caption"><p> Creating a control </p></div></div><p>
       Just try it!
     </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
         GePhex must be running for the control changes to take effect!.
       </p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2491452"></a> Saving the Graph </h3></div></div><div></div></div><p>
        Click on the "Graphs" tab in the info-window.
        Right-click on "first" and choose "Save Graph".
        Done. The graph will be already there when you start next time.
     </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2491468"></a>Chapter 5. Example Graphs</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2491498">Example1: Tunnel-Vision</a></span></dt><dt><span class="sect1"><a href="#id2491513">Example2: Plasma</a></span></dt><dt><span class="sect1"><a href="#id2491523">Example3: A simple Feedback Loop</a></span></dt></dl></div><p> On Un*x, the examples are installed automatically when you run
GePhex for the first time. If not, it might be necessary to remove the
<tt class="filename">~/.gephex</tt> directory from an older version of GePhex.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p> This could delete your graphs, so backup
<tt class="filename">~/.gephex/graphs</tt> if necessary.
</p></div><p>
</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2491498"></a>Example1: Tunnel-Vision</h2></div></div><div></div></div><p>
     Shows how to use the tunnel.
  </p><p>
     Try to attach the frbinmodule (Image Source) module instead of the 
     isingnoize.
  </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2491513"></a>Example2: Plasma</h2></div></div><div></div></div><p>
     Simple plasma effect graph.
  </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2491523"></a>Example3: A simple Feedback Loop</h2></div></div><div></div></div><p>
     Try to change the zoom and rotation of the rotozoom-module.
     If you choose the right parameters, it should look like if you film
     a monitor that displays what you film...
  </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2491536"></a>Chapter 6. Module Reference</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2491542">Generators</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2491547">ifsmodule</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2491586">Input Modules</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2491597">Video-playback (avifilemodule)</a></span></dt><dt><span class="sect2"><a href="#id2491701">Video for Linux (capturemodule)</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2491542"></a>Generators</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2491547"></a>ifsmodule</h3></div></div><div></div></div><p>Linear iterated function systems are a fractal type. The module renders these kind of ifs parameter sets to a image.</p><div class="mediaobject"><img src="images/ifs.png" alt="This is an example for the output of the ifs module."><div class="caption"><p>
      This IFS fractal is rendered in gray scale mode.
      </p></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2491586"></a>Input Modules</h2></div></div><div></div></div><p>In this section all modules are listed, who's main goal is to inject data in from external sources in signal graph.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2491597"></a>Video-playback (avifilemodule)</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2491603"></a>Description</h4></div></div><div></div></div><p>There are different video file-formats. Some can be streamed via net. Others allow random access to each video frame. For some there is a normative standard. mpeg 1,2 and 4 are an example for these kinds. avi, quicktime or real video are (re)defined by their vendors. In most cases the video format is just a wrapper for a video stream encoded with a concrete videocodec.</p><p>The avifile library extracts the compressed video data from the file formats and and provides with the help of its plugins a lot of codecs to decode the frame sequences. The actual support for one format depends on compile time options and the existence of other libraries on your system. Further information is provided at the homepage of the <a href="http://www.avifile.sourceforge.net" target="_top"> <i class="citetitle">avifile</i></a> project.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2491637"></a>Inputs</h4></div></div><div></div></div><p>The first input is the name and path of the video file.</p><p>There are two way to control the playback-position. If the seek input is false the module plays the film sequential frame by frame. The playback starts at the the beginning and plays the sequence once. If the seek input is true the playback-position is controlled by the position input. A zero means jump to the beginning and a 1 to the end. If a signal generator is connected to the position the film can be played in reverse, faster or slower just depending on the parameters of the generator.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2491660"></a>Outputs</h4></div></div><div></div></div><p>The first output is the video-stream.</p><p>The second output is the playback-position in the stream. If the seek is active this is the same as the seek-position but if we disabled seeking this position follows the playback. This output enables looping of parts or setting breakpoints at an arbitrary position.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2491678"></a>Notes</h4></div></div><div></div></div><p>Many codecs don't allow fast seeking to an arbitrary video position. This isn't a problem for standard video playback applications. User of a video effect systems want to reverse the playback direction and jump to an random position in the video-footage. Sequential playback is boring. Watch you favorite movie in sine waves!</p><p>For random access to the video footage it is often necessary to re-encode the material to frame-based codecs like mjpeg. Tools like mencoder of virtual dub are very helpful for these tasks.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2491701"></a>Video for Linux (capturemodule)</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2491707"></a>Description</h4></div></div><div></div></div><p>It is possible to attach several different video-input devices to the computer. Video signals from analog camcorders or vcrs are typically injected by a frame-grabber adapter on the PCI-bus. Digital cameras or low cost web-cams can be connected via USB(2) oder Firewire.</p><p>Most operating systems with multimedia capabilities provide a convenience layer between the video-device drivers and the application. All devices are handled independent of the connection type in a similar fashion.</p><p>Video4Linux (V4L) is the video capture/overlay API of the linux kernel. It is based on the programming interface introduced by the bttv driver. This is a consumer frame-grabber chip used in most tv cards.</p><p>In future linux kernel series this api will be replaced by the successor <a href="http://bytesex.org/v4l/spec/" target="_top"> <i class="citetitle">Video for Linux Two</i></a>. At the moment no GNU/Linux distribution supports this new API in their standard kernels.</p><p>Support for the V4L2 API is planned.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2491754"></a>Inputs</h4></div></div><div></div></div><p>The first input is the number of the video device. A setup with a web-cam and a bttv card e.g. uses the device-files /dev/video0 and /dev/video1. You have to set 0 or 1 at this input.</p><p>It is possible to switch the device during rendering. But with some hardware/driver combinations this results in one or two broken frames.</p><p>The other two inputs tell the frame-grabber the image resolution. A resolution 0,0 forces the grabber to choose any supported resolution.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2491778"></a>Output</h4></div></div><div></div></div><p>The captured frames are sent to the output. In case of an invalid video-device, unsupported image size or any other error a black, full transparent one pixel sized image is returned.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2491791"></a>Notes</h4></div></div><div></div></div><p>The current version of this module is tested with the 2.4.20 kernel drivers of the the <a href="http://www.smcc.demon.nl/webcam/" target="_top"><i class="citetitle">usb web-cam PCVC740K "ToUCam Pro"</i></a> from Phillips and the <a href="http://bytesex.org/bttv/" target="_top"><i class="citetitle">pci bttv848 frame-grabber card win-TV radio</i></a>.</p><p>Further informations about video4linux driver- and user-space programming can be found in the kernel documentation (kernel-source-2.4.20/Documentation/video4linux/API.html and kernel-source-2.4.20/Documentation/DocBook/videobook.tmpl) and in the <a href="https://listman.redhat.com/mailman/listinfo/video4linux-list" target="_top"><i class="citetitle">video4linux mailing list</i></a>.</p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2491837"></a>Chapter 7. Type Reference</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2491842">NumberType</a></span></dt><dt><span class="sect1"><a href="#id2491851">FrameBufferType</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2491842"></a>NumberType</h2></div></div><div></div></div><p>
    64 bit IEEE floating-point value.
  </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2491851"></a>FrameBufferType</h2></div></div><div></div></div><p>
     32-bit BGRA Framebuffertype.
     Orientation is top-down (topmost line is first line in memory).
  </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2491863"></a>Chapter 8. Developer Information</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2491888">Adding new data types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2491964">The c-API</a></span></dt><dt><span class="sect2"><a href="#id2492180">An example for a new data type</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2492400">Adding new effect modules</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2492432">The C-API</a></span></dt><dt><span class="sect2"><a href="#id2492581">Pluc the skeleton generator</a></span></dt><dt><span class="sect2"><a href="#id2493082">An example for a new module</a></span></dt></dl></dd></dl></div><p>The last chapter described the core effect-modules and data-types included with the GePhex package. None of these are hard-coded in the GePhex engine. All of them are plugins that are loaded at startup time.</p><p>This part describes the design for the plugin interfaces.</p><p>The main design goal for these two interfaces was simplicity. It should be possible for a programmer to create a new effect within hours and not days. For the modules there exists a code generator which generates Makefiles, stub code and templates to free the programmer from cut and copy operations.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2491888"></a>Adding new data types</h2></div></div><div></div></div><p>The focus of the GePhex Framework are streams of video-data. The video streams flow from video sources to the output sinks. To control this flow other types of streams are needed. From simple numbers for controlling the video mixers to complex data types for some special effects, we need different types in the data-flow graph.</p><p>The system must be extensible to audio, color-palettes and whatever will be interesting in the future. The types in GePhex are just plugins. You can extend the gephex system with support for new types by providing a shared library, that exports the implementation of a special c-API. The GePhex system loads this library at runtime and creates a type class.</p><p>Recently the midi-type was added. And now we have a module that injects the incoming data from the midi interface into the signal graph. Another module converts the midi-type stream and several number-type outputs. This way, effects with number-types as inputs can be controlled via midi-devices. No changes or rebuilds of the GePhex base system were necessary to add this functionality.</p><p>The modules receive typed values and generate others. Why does the engine need to know anything about the types? Isn't it enough that the affected modules know about the type?</p><p>It is right that the engine doesn't need many internals of the types to do its job, but there are some actions the engine must take care of:</p><p>
</p><div class="itemizedlist"><ul type="disc"><li><p>Provide some informations like the name to the user</p></li><li><p>The renderer must create default values for unconnected inputs</p></li><li><p>The value of type objects must be transfered in a serialized form to the user front-end</p></li></ul></div><p>
</p><p>These the type plugins are like the module plugins shared libraries. They export pointers to functions. The engine then calls these functions if necessary. The symbol names, the signature and the semantic of these are described in the next section.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2491964"></a>The c-API</h3></div></div><div></div></div><p>A GePhex data type plugin is a shared library. There is exact one data type in each library file. The file suffix is .so on the Unix platforms and .dll on ms windows system. Each library exports a set of function symbols as defined in the following section.</p><p>The GePhex type API consists of a required and an additional part. Every type plugin must implement the required part. The loader of a type plugin must ignore plugins that don't export these symbols. By implementing functions of the additional part the serialization and automatic subtype conversion functionality can be enabled. But not for all effects these features are necessary.</p><p>The first group of function are independent of type instances. The functions <tt class="function">init</tt> and <tt class="function">shutdown</tt> handle the (un)loading of the plugin. <tt class="function">getInfo</tt> and <tt class="function">getSpec</tt> allow the host application to query information about the type from the plugin.</p><p>The second group is instance based. There are functions to create and destroy type objects like <tt class="function">newInstance</tt> and <tt class="function">deleteInstance</tt>. Others <tt class="function">assign</tt> and <tt class="function">convertType</tt> instances. The created instances are identified by objects of the type TypeInstanceID this is a unique id with the size of a pointer. It is up to the user of the type plugin to ensure not to mix type object identifier and functions of different types.</p><p>There are two optional features a type can provide: (de)serialization and type attributes.</p><p>Type attributes describe different representations of values and allow to convert between them. A color is can be in the RGB, YUV or HSV color-space. The color doesn't change if the convert between them. It is just the representation that changes. A color type can have a attribute color-space and some functions to convert transparent from one space to another. Types that have attributes must implement <tt class="function">convertType</tt> and <tt class="function">attributesEqual</tt>.</p><p>To store type instances or to transfer them via network it isn't enough to store/transfer the TypeInstanceID we must store the real value not the identifier. The functions <tt class="function">serialize</tt> and <tt class="function">deSerialize</tt> convert type instances to a byte-stream and back.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2492096"></a>Required methods</h4></div></div><div></div></div><div class="refentry" lang="en"><a name="type-api-init"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>init &#8212; initializes the type plugin</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">init</b>(</code><var class="pdparam">void</var><code>)</code>;<br><code>void</code>;</p></div></div><div class="refsect1" lang="en"><a name="id2506417"></a><h2>Description</h2><p>This function initializes the type plugin. It must be called by the shared library loader after resolving all symbols. It may not be called if any error occures while loading the plugin.  No other method of this type class may be called before calling this.</p><p>You can e.g. allocate static memory common to all types in this function to use a memory pool.</p><p>All resources allocated in init must be deallaocated in the shutDown function.</p></div><div class="refsect1" lang="en"><a name="id2530534"></a><h2>Return Value</h2><p>The init function returns a 1 if the type could be initialized and 0 in case of an error. In case of an error no other function (not even the shutdown) may be called.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="type-api-shutDown"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>shutDown &#8212; destructs the type plugin.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">shutDown</b>(</code><var class="pdparam">void</var><code>)</code>;<br><code>void</code>;</p></div></div><div class="refsect1" lang="en"><a name="id2526332"></a><h2>Description</h2><p>This function closes the type library. Before calling it all type instances must be destructed. It must be called before unloading the dll.  After calling shutdown no other method of the type plugin may be called.</p><p>You should free all resources (memory, devices) allocated in init here.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="type-api-getInfo"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>getInfo &#8212; querys the user description of the type</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">getInfo</b>(</code><var class="pdparam">buf</var>, <var class="pdparam">bufLen</var><code>)</code>;<br>char* <code>buf</code>;<br>int <code>bufLen</code>;</p></div></div><div class="refsect1" lang="en"><a name="id2512032"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>buf</tt></i></span></dt><dd><p>This is a pointer to a buffer of size bufLen. This buffer can be modified by the method. If the buffer is big enough the info string is written in it.</p></dd><dt><span class="term"><i class="parameter"><tt>bufLen</tt></i></span></dt><dd><p>bufLen is the size of the buffer buf in bytes.</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="id2534067"></a><h2>Description</h2><p>The getInfo function allows the caller to query some information about the type plugin. These are intended for the user presentation and not needed for rendering an effect. At the moment the caller can get a short description of the type. In the future extensions for i18n, icons and color information will be supported.</p><p>The semantic of this function is that the caller provides a pointer to an allocated array buf of size bufLen. If the infostring fits in that array the string is written in the buffer and the size of the zero-terminated string is returned. If the buffer is to small no changes to the buffer are applied and the needed size is returned.</p><p>The format of the information string is composed like the following example.</p><p>
  </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
    "info { name=Palette }"
  </pre></td></tr></table><p>
</p><p> &lt;INFOSTRING&gt; := info { (&lt;ATTRIBUTENAME&gt;=&lt;ATTRIBUTEVALUE&gt;)+ }</p><p>
At the moment name ist the only attribute that is used.
</p></div><div class="refsect1" lang="en"><a name="id2540514"></a><h2>Return Value</h2><p>It returns the size of the 0 terminated string written in the buffer. If the buffer was to small to store all requested information the needed size is returned and the buffer stays unchanged.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="type-api-getSpec"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>getSpec &#8212; Returns the spec string of type.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">const char* <b class="fsfunc">getSpec</b>(</code><var class="pdparam">void</var><code>)</code>;<br><code>void</code>;</p></div></div><div class="refsect1" lang="en"><a name="id2527448"></a><h2>Description</h2><p>This method returns the specification string of type. This is a c-string with some properties about the type. At the moment this is just the identifier of the type. It is neccessary that this id string is unique cause the type checking in the engine is based on this property.</p><p>For a type called IntType the c-string would look like this:</p><p>
 </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
  "typ_spec { name=typ_IntType; }" 
 </pre></td></tr></table><p>
</p><p> &lt;SPECSTRING&gt; := typ_spec { (&lt;ATTRIBUTENAME&gt;=&lt;ATTRIBUTEVALUE&gt;)+ }</p><p>The name attribute is the only type property used in this version of the api.</p></div><div class="refsect1" lang="en"><a name="id2520095"></a><h2>Return Value</h2><p>The method returns the specification data encoded as a zero terminated string. The pointer to this string is valid till calling shutDown.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="type-api-newInstance"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>newInstance &#8212; creates a new instance of the type</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">typedef void* TypeInstanceID;</pre><p><code class="funcdef">TypeInstanceID <b class="fsfunc">newInstance</b>(</code><code>)</code>;<br>void;</p></div></div><div class="refsect1" lang="en"><a name="id2511917"></a><h2>Description</h2><p>The <tt class="function">newInstance</tt> function creates a new instance of the type. The return value is an identifier with the same memory layout as a pointer. It identifies the typeobject in subsequent calls to the functions of the same type. In most cases this will be a pointer to the memory area allocated to hold the value of the object, but it is not garanteed that this is true. There are different identification mechanisms possible.</p><p>The type objects created by this constructor must be destroyed with a call to the same types <tt class="function">deleteInstance</tt> function. Before calling <tt class="function">shutDown</tt> all instances must be deleted.</p><p>The created type object has a value, the default value.</p></div><div class="refsect1" lang="en"><a name="id2536061"></a><h2>Return Value</h2><p>The function <tt class="function">newInstance</tt> returns a object with the size of a pointer that identifies the type object. This should only passed as an identifier to the type api methods of the same plugin. The caller must ensure not to mix these identifier with the ones of different types.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="type-api-deleteInstance"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>deleteInstance &#8212; deletes a instance of the type</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">typedef void* TypeInstanceID;</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">deleteInstance</b>(</code></td><td><var class="pdparam">instance</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TypeInstanceID  </td><td><var class="pdparam">instance</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="id2549305"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>instance</tt></i></span></dt><dd><p>This is the identifier of the instance to delete.</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="id2535645"></a><h2>Description</h2><p>After using a type object for the last time it must be deleted to free all reserved resources like memory or temporary discspace. <tt class="varname">instance</tt> identifies the type object created with the <tt class="function">createInstance</tt> function of the same type. The caller must ensure not to mix the type identifiers of one type with the functions of another type. After calling this method the object <tt class="varname">instance</tt> is invalid. The instance identifier mustn't used anymore. All type instances created with <tt class="function">newInstance</tt> must be destroyed with <tt class="function">deleteInstance</tt> before calling <tt class="function">shutDown</tt> of their type.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="type-api-assign"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>assign &#8212; 
      Assigns the value of the source to the destination typeobject.
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">typedef void* TypeInstanceID;</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">assign</b>(</code></td><td><var class="pdparam">destination</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">source</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TypeInstanceID  </td><td><var class="pdparam">destination</var>;</td></tr><tr><td>TypeInstanceID  </td><td><var class="pdparam">source</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="id2427570"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>destination</tt></i></span></dt><dd><p>The value of this type instance will be changed to the value of <i class="parameter"><tt>source</tt></i>.</p></dd><dt><span class="term"><i class="parameter"><tt>source</tt></i></span></dt><dd><p>The value of this type instance is assigned to the <i class="parameter"><tt>destination</tt></i> instance. The value of <i class="parameter"><tt>source</tt></i> stays unchanged.</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="id2551554"></a><h2>Description</h2><p><tt class="varname">source</tt> and <tt class="varname">destination</tt> are identifier for two type objects of the same type as the typeclass. After a call to this function the value of the source object stays unchanged and the value of destination is changed to the one of source. It is the callers task to ensure that both instances and the <tt class="function">assign</tt> function have the same type.</p></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2492148"></a>Optional methods</h4></div></div><div></div></div><div class="refentry" lang="en"><a name="type-api-serialize"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>serialize &#8212; serialize the value</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">typedef void* TypeInstanceID;</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">int <b class="fsfunc">serialize</b>(</code></td><td><var class="pdparam">instance</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">buffer</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">bufferLen</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TypeInstanceID  </td><td><var class="pdparam">instance</var>;</td></tr><tr><td>char*  </td><td><var class="pdparam">buffer</var>;</td></tr><tr><td>int  </td><td><var class="pdparam">bufferLen</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="id2501731"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>instance</tt></i></span></dt><dd><p>The value of this type instance will be serialized in the <i class="parameter"><tt>buffer</tt></i>. The value of <i class="parameter"><tt>instance</tt></i> stays unchanged.</p></dd><dt><span class="term"><i class="parameter"><tt>buffer</tt></i></span></dt><dd><p>This is a pointer to an buffer with the size <i class="parameter"><tt>bufferLen</tt></i>. If the buffer is big enough the value of <i class="parameter"><tt>instance</tt></i> will be stored serialized in this buffer.</p></dd><dt><span class="term"><i class="parameter"><tt>bufferLen</tt></i></span></dt><dd><p>This is the size of the <i class="parameter"><tt>buffer</tt></i> in bytes.</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="id2542495"></a><h2>Description</h2><p>The function serializes the value of <i class="parameter"><tt>instance</tt></i> into the <i class="parameter"><tt>buffer</tt></i> with the size <i class="parameter"><tt>bufferLen</tt></i>. If the buffer provided by the caller isn't big enough for the serialized value the <i class="parameter"><tt>buffer</tt></i> is not changed and the required size is returned. In the other case the value of <i class="parameter"><tt>instance</tt></i> is written as a bytesequence to the front of the buffer and the number of used bytes is returned.</p><p>This method is optional. If you want to provide the (de)serialisation functionality you must also implement the <tt class="function">deSerialize</tt> method.
</p></div><div class="refsect1" lang="en"><a name="id2542534"></a><h2>Return Value</h2><p>If the buffer is big enough the number of written bytes is returned. In the other case the return value is the number of needed bytes.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="type-api-deSerialize"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>deSerialize &#8212; assign the type instance the serilaized value </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">typedef void* TypeInstanceID;</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">deSerialize</b>(</code></td><td><var class="pdparam">buffer</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">bufferLen</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">instance</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char*  </td><td><var class="pdparam">buffer</var>;</td></tr><tr><td>int  </td><td><var class="pdparam">bufferLen</var>;</td></tr><tr><td>TypeInstanceID  </td><td><var class="pdparam">instance</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="id2523749"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>instance</tt></i></span></dt><dd><p>The value of this type instance will be changed to the one of the <i class="parameter"><tt>buffer</tt></i>.</p></dd><dt><span class="term"><i class="parameter"><tt>buffer</tt></i></span></dt><dd><p>This is a pointer to an buffer of size <i class="parameter"><tt>bufferLen</tt></i>. The buffer holds the value that is assigned to the <i class="parameter"><tt>instance</tt></i> type object. The buffer will not be changed.</p></dd><dt><span class="term"><i class="parameter"><tt>bufferLen</tt></i></span></dt><dd><p>This is the size of the <i class="parameter"><tt>buffer</tt></i> in bytes.</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="id2535779"></a><h2>Description</h2><p>The function <tt class="function">deSerialize</tt> gets a <i class="parameter"><tt>buffer</tt></i> with a serialized value of the type and a instance of the same type. After calling this function the value of type instance is changed to the one in the serialized buffer. The caller must ensure that the value in the <i class="parameter"><tt>buffer</tt></i>, the <i class="parameter"><tt>instance</tt></i> typeobject and the <tt class="function">deSerialize</tt> function have the same type.</p><p>This function is optional. A type plugin that provides (de)serialisation functionality must also implement the inverse function <tt class="function">serialize</tt>.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="type-api-attributesEqual"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>attributesEqual &#8212; 
      compares attributes with the of one type instance
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">typedef void* TypeInstanceID;
typedef void* TypeAttributesInstanceID;</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">attributesEqual</b>(</code></td><td><var class="pdparam">instance</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">attributes</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TypeInstanceID  </td><td><var class="pdparam">instance</var>;</td></tr><tr><td>TypeAttributesInstanceID  </td><td><var class="pdparam">attributes</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="id2501707"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>instance</tt></i></span></dt><dd><p>The attributes of this type object are compared with the second parameter <i class="parameter"><tt>attributes</tt></i></p></dd><dt><span class="term"><i class="parameter"><tt>attributes</tt></i></span></dt><dd><p>These attributes are compared with the attributes of the <i class="parameter"><tt>instance</tt></i>.</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="id2502093"></a><h2>Description</h2><p>The <tt class="function">attributesEqual</tt> function compares the attributes of <i class="parameter"><tt>instance</tt></i> with the <i class="parameter"><tt>attributes</tt></i>.</p><p>An example for an datatype with attributes is the framebuffer type. The resolution is an attribute of the type. There are also other attributes thinkable like colormodel (RGB, BGR, YUV) or the memory layout of the pixels. It must be possible to change the attributes without changing the abstract value of the type instance</p><p>This function is optional. Types with attributes must also provide the <tt class="function">convertType</tt> function.</p></div><div class="refsect1" lang="en"><a name="id2502129"></a><h2>Return Value</h2><p>The funtion returns 1 if the attributes are equal and 0 in the other cases.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="type-api-convertType"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>convertType &#8212; 
      Assigns the value from src to dst and changes the attributes while doing that.
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">typedef void* TypeInstanceID;
typedef void* TypeAttributesInstanceID;</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">convertType</b>(</code></td><td><var class="pdparam">destination</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">source</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">attributes</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TypeInstanceID  </td><td><var class="pdparam">destination</var>;</td></tr><tr><td>TypeInstanceID  </td><td><var class="pdparam">source</var>;</td></tr><tr><td>TypeAttributesInstanceID  </td><td><var class="pdparam">attributes</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="id2538235"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>destination</tt></i></span></dt><dd><p>The value of this type object is changed to the one of <i class="parameter"><tt>destination</tt></i> and the attributes of <i class="parameter"><tt>source</tt></i> will then equal <i class="parameter"><tt>attributes</tt></i>.</p></dd><dt><span class="term"><i class="parameter"><tt>source</tt></i></span></dt><dd><p>The value of this type objects is assigned to <i class="parameter"><tt>destination</tt></i> while changing the attributes to <i class="parameter"><tt>attributes</tt></i>. The type insance <i class="parameter"><tt>source</tt></i> stays unchanged.</p></dd><dt><span class="term"><i class="parameter"><tt>attributes</tt></i></span></dt><dd><p>These attributes are the new attributes of <i class="parameter"><tt>destination</tt></i>.</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="id2495124"></a><h2>Description</h2><p>The <tt class="function">changeAttributes</tt> converts the value of the <i class="parameter"><tt>source</tt></i> type instance to the <i class="parameter"><tt>attributes</tt></i> and assigns the result to the <i class="parameter"><tt>destination</tt></i> instance.</p><p>This function is optional. Types with attributes must also implement the <tt class="function">attributesEqual</tt> function.</p></div></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2492180"></a>An example for a new data type</h3></div></div><div></div></div><p>The following chapter describes the necessary steps to implement a new data type plugin. The new type will be a color palette. Mathematically this is is a mapping from an interval to the color-space. Since the standard color-space in the GePhex is the red-green-blue color-model with 256 discrete steps from each color-channel and a source space with 256 elements the palette can easily implemented as a array with 256 RGBA entries.</p><p>The implementation of the new type is split up in two files: palettetype.h and palettetype.c. The .c file includes the header and will be compiled to the shared library. In the .c files are the exported functions defined. The memory layout of the type and all helper methods resists in the header-file, cause all modules that use the type include the header and do not link with the shared library.</p><p>We define the memory layout of the new type in the header in a straight forward way:
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
typedef struct PaletteType_
{
  uint_32 pal[256];
} PaletteType;
</pre></td></tr></table><p>

uint_32 is a typedef for an unsigned integer with 32 bit size. It is defined in the header <tt class="filename">basic_types.h</tt>. The 32 bits of the integer are composed by the 4 color components red, green, blue and alpha.</p><p>The next step is to define the functions of the shared library. To keep it simple we'll implement only the necessary core methods: <tt class="function">getInfo</tt>,<tt class="function">getSpec</tt>,<tt class="function">deleteInstance</tt>,<tt class="function">newInstance</tt> and <tt class="function">assign</tt></p><p>The implementation of getInfo and getSpec are similarly for all types  their propose is to deliver type-specific info strings to the caller. For the new type we set these two strings to:</p><p> "typ_spec { name=typ_PaletteType; }" and "info { name=Palette }".</p><p>
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
const char* getSpec(void)
{
  // return the specification string
  return "typ_spec { name=typ_PaletteType; }";
}

int getInfo (char* buf,int bufLen)
{
  static const char* INFO = "info { name=Palette }";
  int reqLen = strlen(INFO) + 1;
  // check if the buffer is big enough
  if (buf != 0 &amp;&amp; reqLen &lt;= bufLen)
    {
      // the string fits in, copy it
      memcpy(buf,INFO,reqLen);
    }
  return reqLen;
</pre></td></tr></table><p>
</p><p>The other three mandatory functions are the constructor, the destructor and assignment method. In the .c file we place simple wrappers to the real methods in the header. This ensures that modules and the engine use the same implementation since the modules include the type-headers and the engine loads the shared libraries.
</p><p>
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
void* newInstance(void)
{
  return palette_newInstance();
}

void assign(void* dst,const void* src)
{
  palette_assign((PaletteType*)dst,(const PaletteType*)src);
}

void deleteInstance(void* pal)
{
  palette_deleteInstance((PaletteType*) pal);
}
</pre></td></tr></table><p>
</p><p> The actual implementation of the functions <tt class="function">palette_newInstance</tt>, <tt class="function">palette_assign</tt> and <tt class="function">palette_deleteInstance</tt> is in the header.</p><p>The creation of a new type object is split into two functions: one for memory allocation and the other for initialization it with the default value.</p><p>
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting"> 
// initialize a palette with the default value
static __inline void number_initInstance(PaletteType* newType)
{
  int i;
  for(i=0;i!=256;++i)
    {
      newType-&gt;palette[i] = 0x00000000;
    }
}

// allocate memory for a new palette type-object and initialize it
static __inline PaletteType* palette_newInstance(void)
{
  PaletteType* newType = (PaletteType*) malloc(sizeof(PaletteType));
  palette_initInstance(newType);
  return newType;
}
</pre></td></tr></table><p>
</p><p>The assign method just copies the entries of the source array to the destination.</p><p>
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting"> 
// assign the value of the source palette to the destination palette
static __inline void palette_assign(PaletteType* dst,const PaletteType* src)
{ 
  dst-&gt;palette = src-&gt;palette;
int i;
  for(i=0;i!=256;++i)
    {
      dst-&gt;palette[i] = src-&gt;palette[i];
    }
}
</pre></td></tr></table><p>
</p><p>The type allocates memory the destructor must free this resource for reuse.</p><p>
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting"> 
/* frees the allocated memory for a palette type object */
static __inline void palette_deleteInstance(PaletteType* pal)
{
  free(pal);
}
</pre></td></tr></table><p> 
</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2492400"></a>Adding new effect modules</h2></div></div><div></div></div><p>
To add a new effect module, it is best to use pluc, our plugin code generator.
It can produce much of the boilerplate code from a simple module
specification (see ...).
</p><p>
While a module must export plain C functions, it is possible to use other
languages for the implementation. Many of GePhex's modules are internally
written in C++.
</p><p>
The most important function of a module is update. Here the module can read
the input values and produce new output values.
</p><p>The outputs and needed inputs are always initialized by the engine
before the update method is called.
The module itself is responsible to convert outputs and inputs if necessary
(E.g. some modules want both their input images to have the same resolution,
or they want to have the output image to be the same resolution as the input
image).
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2492432"></a>The C-API</h3></div></div><div></div></div><p>A module is a shared library that exports some c functions. In the following section the necessary and the optional methods and their semantics are described.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2492442"></a>The Core Methods</h4></div></div><div></div></div><p> Every module must implement these functions and export their symbol. The loader of the shared library must ignore modules with missing symbols.</p><div class="refentry" lang="en"><a name="module-api-init"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>init &#8212; initialize the plugin</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">typedef void (*logT) (int, const char*);</pre><p><code class="funcdef">int <b class="fsfunc">init</b>(</code><var class="pdparam">logger</var><code>)</code>;<br>logT <code>logger</code>;</p></div></div><div class="refsect1" lang="en"><a name="id2517218"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><i class="parameter"><tt>logger</tt></i></span></dt><dd><p>Callback to send log messages from the module plugin to the host application.</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="id2506210"></a><h2>Description</h2><p>The <tt class="function">init</tt> function initialises the module plugin. It is the first function called after loading the shared library. No other method may be called before calling this. It is only allowed to call this function once. The propose is to initialise resources common to all instances of this module class. For example allocation of a memory pool or querys for i/o devices.</p><p>If the return value signals an error the caller is not allowed to call another function. The proper handling of such a situation is unloading the shared library.</p><p><i class="parameter"><tt>logger</tt></i> is a pointer to a function that is used to send log messages from the module to the engine. The first parameter of this function is the log level and the second is a const char pointer to the log message as c-string.</p></div><div class="refsect1" lang="en"><a name="id2499739"></a><h2>Return Value</h2><p>The return value is 1 if the module could be initialised and 0 in case of an error.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-shutDown"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>shutDown &#8212; closes the module plugin</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">shutDown</b>(</code><code>)</code>;<br>void;</p></div></div><div class="refsect1" lang="en"><a name="id2517999"></a><h2>Description</h2><p>This function must be called before unloading the shared library. After invoking <tt class="function">shutdown</tt> no other methods of the module may be called. In this method all class-wide resources allocated e.g. by the <tt class="function">init</tt> function must be released. Before calling this method all instances created with <tt class="function">newInstance</tt> must be deleted by calling <tt class="function">deleteInstance</tt></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-getspec"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>getSpec &#8212; querys the spefification from the module</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">char* <b class="fsfunc">getSpec</b>(</code><code>)</code>;<br>void;</p></div></div><div class="refsect1" lang="en"><a name="id2534601"></a><h2>Description</h2><p>This function querys a specification string from the modules plugin. It stores the unique string identifier of the module, the number of inputs and outputs
</p><p>
  </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
mod_spec 
   { 
     name = mod_STRING; 
     number_of_inputs = UINT; 
     number_of_outputs = UINT; 
     deterministic = BOOL 
   }</pre></td></tr></table><p>
</p></div><div class="refsect1" lang="en"><a name="id2532599"></a><h2>Return Value</h2><p>The module specification string is returned as a pointer to a zero terminated char array. This pointer stays valid until calling <tt class="function">shutDown</tt>.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-getInfo"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>getInfo &#8212; query information for the user interface</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">int <b class="fsfunc">getInfo</b>(</code><var class="pdparam">buffer</var>, <var class="pdparam">bufLen</var><code>)</code>;<br>char* <code>buffer</code>;<br>int <code>bufLen</code>;</p></div></div><div class="refsect1" lang="en"><a name="id2500988"></a><h2>Description</h2><p>For the dynamic creation of the user interface several information about the module class are necessary:</p><p>
  </p><div class="itemizedlist"><ul type="disc"><li><p>icon, name, effect-group</p></li><li><p>information about the inputs</p></li><li><p>information about the outputs</p></li></ul></div><p>
</p><p>These information are const that means subsequent calls to this function must return the same value.</p><p>The semantic of this function is that the caller gives a pointer to a
already allocated array buf of size bufLen and if the info string fits
in that array the string is copied and the size of the 0 terminated
string is returned. If the buffer is to small no changes to the buffer
are applied and the needed size is returned.</p></div><div class="refsect1" lang="en"><a name="id2513597"></a><h2>Return Value</h2><p>The function returns the number of written bytes or if the provided buffer was to small the minimum buffer size to store the info string</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-getInputSpec"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>getInputSpec &#8212; query a description of an input</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">char* <b class="fsfunc">getInputSpec</b>(</code><var class="pdparam">index</var><code>)</code>;<br>int <code>index</code>;</p></div></div><div class="refsect1" lang="en"><a name="id2550100"></a><h2>Description</h2><p>
This function returns a pointer to a c-string which describes the input with 
the <i class="parameter"><tt>index</tt></i> number.
The format of this specification string looks similar to a structure with
default values in programming languages.
The structure is called <tt class="literal">input_spec</tt> in it has the attributes
<tt class="literal">type</tt>, <tt class="literal">id</tt>, <tt class="literal">const</tt>,
<tt class="literal">default</tt> and <tt class="literal">strong_dependency</tt>.
<span class="returnvalue"> 
"input_spec { type=typ_STRING; id=STRING; const=BOOL; strong_dependency=BOOL; default=STRING}"
</span> 
The order of the attributes is irrelevant.
<tt class="literal">type</tt> is the unique identifier for the type-class of
that input.
<tt class="literal">id</tt> is an identifier for this input. It has to be unique
among all inputs of the module.
With the <tt class="literal">const</tt> attribute signals the modules to the engine
if it wants to change the value of the type object in the
<tt class="function">update</tt> function.
If the input has set <tt class="literal">strong_dependency</tt> to true the engine
must always set/update this input before calling <tt class="function">update</tt>.
The <tt class="literal">default</tt> attribute is the default value of the input
when the module is new created. The format to specify this value is the format
defined by the <tt class="function">serialise</tt> and
<tt class="function">deserialise</tt> functions of the type-class.
The specification for some input could look like this:
<tt class="literal">"input_spec { type=typ_NumberType id=factor const=true strong_dependency=true default=0 }"</tt>
</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-getOutputSpec"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>getOutputSpec &#8212; query the specification of an output</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">char* <b class="fsfunc">getOutputSpec</b>(</code><var class="pdparam">index</var><code>)</code>;<br>int <code>index</code>;</p></div></div><div class="refsect1" lang="en"><a name="id2548809"></a><h2>Description</h2><p>Format:
"output_spec { type=typ_STRING; id=STRING }"</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-newInstance"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>newInstance &#8212; create a new instance of the module</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void* <b class="fsfunc">newInstance</b>(</code><code>)</code>;<br>void;</p></div></div><div class="refsect1" lang="en"><a name="id2550906"></a><h2>Description</h2><p>By calling this method a new instance of the module class is created. The return value is a pointer to the instance. This pointer may only be used by the methods of the same module class. The caller must always ensure that these instance pointers fit to the corresponding functions. There needn't be any internal type check in the module implementation. After using this instance the allocated resources must be released by calling <tt class="function">deleteInstance</tt>.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-deleteInstance"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>deleteInstance &#8212; deletes a module instance</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">deleteInstance</b>(</code><var class="pdparam">instance</var><code>)</code>;<br>void* <code>instance</code>;</p></div></div><div class="refsect1" lang="en"><a name="id2529067"></a><h2>Description</h2><p>To free the allocated module instance resources the engine calls <tt class="function">deleteInstance</tt>. It must call this destructor after last usage of the module instance. The <i class="parameter"><tt>instance</tt></i> pointer is invalid after this call and may not be used for further calls.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-setInput"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>setInput &#8212; Sets the reference to the typeobject with the input value</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">int <b class="fsfunc">setInput</b>(</code></td><td><var class="pdparam">instance</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">inputIndex</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">typeObject</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>void*  </td><td><var class="pdparam">instance</var>;</td></tr><tr><td>int  </td><td><var class="pdparam">inputIndex</var>;</td></tr><tr><td>void*  </td><td><var class="pdparam">typeObject</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="id2531888"></a><h2>Description</h2><p>The <i class="parameter"><tt>typeObject</tt></i> that holds the value for the input with index <i class="parameter"><tt>inputIndex</tt></i> of the module <i class="parameter"><tt>instance</tt></i> are set with this function. If the input is declared as const the module may not change the value of the type object because the engine can in this case provide it to another module as input.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-setOutput"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>setOutput &#8212; sets the referenz to the typeobject to assign the output value</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">int <b class="fsfunc">setOutput</b>(</code></td><td><var class="pdparam">instance</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">outputIndex</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">typeObject</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>void*  </td><td><var class="pdparam">instance</var>;</td></tr><tr><td>int  </td><td><var class="pdparam">outputIndex</var>;</td></tr><tr><td>void*  </td><td><var class="pdparam">typeObject</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="id2527304"></a><h2>Description</h2><p>A module doesn't create an output type-object with an <tt class="function">update</tt>. It assigns the calculated values to the output objects provided by the caller. This method sets the <i class="parameter"><tt>type-object</tt></i> for the output with index <i class="parameter"><tt>outputIndex</tt></i> of the module <i class="parameter"><tt>instance</tt></i>.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-update"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>update &#8212; process the inputs and assigns the results to the outputs</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">update</b>(</code><var class="pdparam">instance</var><code>)</code>;<br>void* <code>instance</code>;</p></div></div><div class="refsect1" lang="en"><a name="id2530478"></a><h2>Description</h2><p>After all necessary inputs and outputs are set with the <tt class="function">setInput</tt> and <tt class="function">setOutput</tt> the engine can call <tt class="function">update</tt> to assign the results to the outputs. </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-update"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>update &#8212; process the inputs and assigns the results to the outputs</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">update</b>(</code><var class="pdparam">instance</var><code>)</code>;<br>void* <code>instance</code>;</p></div></div><div class="refsect1" lang="en"><a name="id2545582"></a><h2>Description</h2><p>After all necessary inputs and outputs are set with the <tt class="function">setInput</tt> and <tt class="function">setOutput</tt> the engine can call <tt class="function">update</tt> to assign the results to the outputs. </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-getInputAttributes"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>getInputAttributes &#8212; get type-attributes for input</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><p><code class="funcdef">void* <b class="fsfunc">getInputAttributes</b>(</code><var class="pdparam">inputIndex</var><code>)</code>;<br>int <code>inputIndex</code>;</p></div></div><div class="refsect1" lang="en"><a name="id2589996"></a><h2>Description</h2><p>If the type-class of an input supports type attributes an module can force an automatic conversion to fixed attributes. This method returns these attributes. If it returns 0 the input has no fixed attribute or the type doesn't support attributes. inputIndex is the number of the input the caller want to obtain the information.</p></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2492532"></a>Optional Methods</h4></div></div><div></div></div><p>
To enable additional functionality the shared library must export some of the the following methods. The functions are used for optimization:
</p><div class="itemizedlist"><ul type="disc"><li><p>In some cases not all inputs of a module need to be calculated. A switch for example has three inputs and one output. The control input decides which of the two other inputs should be assigned to the output. If the control input is known there is only one of the two inputs needed. We can eliminate the costs for calculating the subtree starting at the unused input by first calculation the control input and when we know its value only calculating one of the two other inputs.</p></li><li><p>To copy big type objects like images is expensive. In some cases we know that a module copies the value of an input to an output and makes no or little changes. In this case the engine can eliminate a copy if the input object is exclusively used by only one module.</p></li></ul></div><p>
</p><div class="refentry" lang="en"><a name="module-api-getPatchLayout"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>getPatchLayout &#8212; returns the patch-layout for the next update</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">getPatchLayout</b>(</code></td><td><var class="pdparam">instance</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">out2in</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>void*  </td><td><var class="pdparam">instance</var>;</td></tr><tr><td>int**  </td><td><var class="pdparam">out2in</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="id2595314"></a><h2>Description</h2><p>This function returns the patch-layout for the next update. This is a mapping of all outputs to the inputs. If an output is mapped to an input the engine must ensure that before the <tt class="function">update</tt> the output has the same value as the input. If no mapping is requested for an output there are no guarantees for the value of the output object. It must be called direct before <tt class="function">update</tt>. Every output entry holds the index of the input that should be patched to the output. The array has entries for every output. Every output entry holds the index of the input that should be patched to the output. It the entry is -1 the no patching is requested.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="module-api-strongDependenciesCalculated"></a><div class="titlepage"><div></div><div></div></div><div class="refnamediv"><h2>Name</h2><p>strongDependenciesCalculated &#8212; query the needed inputs</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">strongDependenciesCalculated</b>(</code></td><td><var class="pdparam">instance</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">neededInputs</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>void*  </td><td><var class="pdparam">instance</var>;</td></tr><tr><td>int**  </td><td><var class="pdparam">neededInputs</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="id2599619"></a><h2>Description</h2><p>This function returns the needed inputs for the next call to <tt class="function">update</tt>. Before calling <tt class="function">strongDependenciesCalculated</tt> the strong-dependency inputs must be updated. The caller provides an array of ints with the same number of elements as inputs. An 0 entry means the value is needed and must be up to date before calling <tt class="function">update</tt>. If the entry for an input is 0 the input needn't be calculated.</p></div></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2492581"></a>Pluc the skeleton generator</h3></div></div><div></div></div><p>
The c-api design allows module developers to write their plugins in almost
any programming language.
This is achieved by a very low-level interface between host and plugin.
</p><p>
Pluc is distributed with GePhex in the <tt class="filename">modules</tt>
 subdirectory.
</p><p>
Many module functions are very simple and have just some lines of code.
We want to implement a module that outputs the maximum of its number
inputs. In c++ this would be a one-liner:
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
double output1,input1,input2;
output1 = std::max(input1,input2)
</pre></td></tr></table><p>
But the effort needed to export this piece of code via the c-api interface
is huge. This is the reason why the pluc.py stub generator exists.
</p><p>
The idea of pluc is that many properties of a module are described in a 
spec file. Pluc can generate from this file:
</p><div class="itemizedlist"><ul type="disc"><li><p>
the build-system files (for automake and MS Visual Studio)
</p></li><li><p>
a convenience layer to abstract from the c-api
</p></li><li><p>
a minimum skeleton code for the module implementation
that can be used as a basis for implementing the function.
</p></li></ul></div><p>Sample invocations of pluc:
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
pluc.py dsp testmodule.spec 
pluc.py am testmodule.spec 
pluc.py skel testmodule.spec 
</pre></td></tr></table><p>
As can be seen, the first argument to pluc is a command.
The second is the filename of the plugin specification.
</p><div class="table"><a name="id2492659"></a><p class="title"><b>Table 8.1. Most important pluc commands</b></p><table summary="Most important pluc commands" border="1"><colgroup><col><col></colgroup><tbody><tr><td>am</td><td>Creates an automake Makefile.am</td></tr><tr><td>dsp</td><td>Creates a Visual Studio project</td></tr><tr><td>skel</td><td>Creates skeleton code for the plugin</td></tr></tbody></table></div><p>
</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2492695"></a>Syntax and semantics of the spec file</h4></div></div><div></div></div><p>
A spec file consists of three parts. Each part is composed of an identifier
followed by a block enclosed in curly braces.
The first part contains global settings that determine the behavior of the
whole module.
The second part contains settings for all inputs of the module.
The third part contains settings for all outputs of the module.
</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id2492710"></a>Global settings</h5></div></div><div></div></div><p>
The global settings begin with a unique name for the module, by
convention prefixed with "mod_". To stick with the example from above
we choose "mod_max".
</p><div class="table"><a name="id2492722"></a><p class="title"><b>Table 8.2. Mandatory global settings</b></p><table summary="Mandatory global settings" border="1"><colgroup><col><col></colgroup><tbody><tr><td>name</td><td>STRING</td></tr><tr><td>deterministic</td><td>BOOL</td></tr><tr><td>group</td><td>STRING</td></tr><tr><td>xpm</td><td>FILENAME</td></tr><tr><td>author</td><td>STRING</td></tr><tr><td>version</td><td>STRING</td></tr></tbody></table></div><p>
</p><div class="variablelist"><dl><dt><span class="term">name</span></dt><dd><p>the name that is visible to the user</p></dd><dt><span class="term">deterministic</span></dt><dd><p>specifies if the module produces the
     same output whenever the input is the same. This is for example not true
    for a module that produces random numbers.</p></dd><dt><span class="term">group</span></dt><dd><p>allows to group several effects</p></dd><dt><span class="term">xpm</span></dt><dd><p>the name of a xpm file that is used as an icon
                    for this module</p></dd></dl></div><p>
</p><p>
The following settings are optional:
</p><div class="itemizedlist"><ul type="disc"><li><p>enablePatching: BOOL</p></li></ul></div></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id2492847"></a>Input settings</h5></div></div><div></div></div><p>
The settings in the input block determine the type, default value and other
attributes for every input.
</p><p>
The input block is composed of several blocks, one for each input.
</p><p>
</p><div class="table"><a name="id2492864"></a><p class="title"><b>Table 8.3. Mandatory input settings</b></p><table summary="Mandatory input settings" border="1"><colgroup><col><col></colgroup><tbody><tr><td>name</td><td>STRING</td></tr><tr><td>type</td><td>STRING</td></tr><tr><td>const</td><td>BOOL</td></tr><tr><td>strong_dependency</td><td>BOOL</td></tr></tbody></table></div><p>
</p><p>
</p><div class="variablelist"><dl><dt><span class="term">name</span></dt><dd><p>the name that is visible to the user</p></dd><dt><span class="term">type</span></dt><dd><p>the type of the input (number, framebuffer, audio, color,...)     </p></dd><dt><span class="term">const</span></dt><dd><p>true iff the module does not change the value of the input
       </p></dd><dt><span class="term">strong_dependency</span></dt><dd><p>true iff this input is needed every frame</p></dd></dl></div><p>
</p><p>
These attributes are optional.
</p><div class="table"><a name="id2492964"></a><p class="title"><b>Table 8.4. Optional input settings</b></p><table summary="Optional input settings" border="1"><colgroup><col><col></colgroup><tbody><tr><td>default</td><td>STRING</td></tr><tr><td>version</td><td>STRING</td></tr></tbody></table></div><p>

</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
You can provide more optional settings. They are not checked by the
engine and can be used to give more information to the gui.
</p></div><p>
</p><p>
Here is an input block with two number inputs.
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
inputs
{
    lhs
    {
      name              = x
      type              = typ_NumberType
      const             = true
      strong_dependency = true
      default           = 0
      widget_type       = unboundednumber_selector
    }

    rhs
    {
      name              = y
      type              = typ_NumberType
      const             = true
      strong_dependency = true
      widget_type       = unboundednumber_selector
      default           = 0
    }
}
</pre></td></tr></table><p>
</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id2493021"></a>Output settings</h5></div></div><div></div></div><p>
The settings in the output block determine the type and name for every output.
</p><p>
The output block is composed of several blocks, one for each output.
</p><p>
</p><div class="table"><a name="id2493038"></a><p class="title"><b>Table 8.5. Mandatory output settings</b></p><table summary="Mandatory output settings" border="1"><colgroup><col><col></colgroup><tbody><tr><td>name</td><td>STRING</td></tr><tr><td>type</td><td>STRING</td></tr></tbody></table></div><p>
</p><p>
Example for an output block with one output:
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
outputs
{
    r
    {
    name              = Result
    type              = typ_NumberType
    }
}
</pre></td></tr></table><p>
</p></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2493082"></a>An example for a new module</h3></div></div><div></div></div><p>Putting all together, the complete spec for our <tt class="literal">max</tt>
module looks like this:
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
mod_maxmodule
{
    name              = Maximator
    deterministic     = true
    group             = Number
    xpm               = maxmodule.xpm
    author            = Zardoz
    version           = 1.0
}

inputs
{
    lhs
    {
      name              = x
      type              = typ_NumberType
      const             = true
      strong_dependency = true
      default           = 0
      widget_type       = unboundednumber_selector
    }

    rhs
    {
      name              = y
      type              = typ_NumberType
      const             = true
      strong_dependency = true
      widget_type       = unboundednumber_selector
      default           = 0
    }
}

outputs
{
    r
    {
      name              = Result
      type              = typ_NumberType
    }
}
</pre></td></tr></table><p>
</p><p>
Let's assume the spec file is called <tt class="filename">maxmodule.spec</tt>.
The next step is to produce a <tt class="filename">Makefile.am </tt>
and the skeleton code:
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
 &gt; pluc.py am maxmodule.spec
 &gt; pluc.py skel maxmodule.spec
</pre></td></tr></table><p>
</p><p>
The skeleton code will be called maxmodule.c. After you have included
the <tt class="filename">Makefile.am</tt> into your build system, the
glue code will be automatically generated when you compile the maxmodule.
So whats left to do is to edit the <tt class="literal">update</tt> method
in <tt class="filename">maxmodule.c</tt>:
</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="screen">
void update(void* instance)
{
  InstancePtr inst    = (InstancePtr) instance;

  inst-&gt;out_r-&gt;number = max(inst-&gt;in_lhs-&gt;number, inst-&gt;in_rhs-&gt;number);
}
</pre></td></tr></table><p>
That's all!
</p></div></div></div></div></body></html>
